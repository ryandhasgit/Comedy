/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
var main_exports = {};
__export(main_exports, {
  SettingsTab: () => SettingsTab,
  default: () => TaggedDocumentsViewer
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// utils/links.ts
function isMacOS() {
  var _a;
  const platform = ((_a = navigator == null ? void 0 : navigator.userAgentData) == null ? void 0 : _a.platform) || (navigator == null ? void 0 : navigator.platform);
  return platform.toLowerCase().startsWith("mac");
}
function isMetaKey(event) {
  return isMacOS() ? event.metaKey : event.ctrlKey;
}
function openLink(app, dest, currFile, event) {
  return __async(this, null, function* () {
    const destFile = app.metadataCache.getFirstLinkpathDest(dest, currFile.path);
    const mode = app.vault.getConfig("defaultViewMode");
    const leaf = app.workspace.getLeaf(isMetaKey(event));
    yield leaf.openFile(destFile, { active: true, mode });
  });
}
function createLink(app, file, onClick) {
  const link = createTextContent("a", file.basename);
  link.style.cursor = "pointer";
  link.dataset.href = file.path;
  link.classList.add("internal-link");
  link.onclick = (e) => {
    openLink(app, file.path, file, e);
    if (typeof onClick === "function") {
      onClick(e);
    }
  };
  return link;
}
function createTextContent(element, content) {
  const el = document.createElement(element);
  el.setText(content);
  return el;
}

// main.ts
var DEFAULT_SETTINGS = {
  displayRibbonIcon: true,
  openModalOnClick: true,
  requireOptionKey: false
};
var SettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Display Ribbon Icon").setDesc("Display a ribbon icon which will open the modal when clicked.").addToggle((component) => {
      component.setValue(this.plugin.settings.displayRibbonIcon).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.displayRibbonIcon = value;
        this.plugin.onSettingChange(0 /* DisplayRibbonIcon */, value);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Open Modal On Click").setDesc("Open the model when a tag is clicked.").addToggle((component) => {
      component.setValue(this.plugin.settings.openModalOnClick).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.openModalOnClick = value;
        this.plugin.onSettingChange(1 /* OpenModalOnClick */, value);
        yield this.plugin.saveSettings();
      }));
    });
    new import_obsidian.Setting(containerEl).setName("Require Alt/Option Key").setDesc("Require the alt/option key to be down when clicking a tag.").addToggle((component) => {
      component.setValue(this.plugin.settings.requireOptionKey).onChange((value) => __async(this, null, function* () {
        this.plugin.settings.requireOptionKey = value;
        this.plugin.onSettingChange(2 /* RequireOptionKey */, value);
        yield this.plugin.saveSettings();
      }));
    });
  }
};
var TaggedDocumentsViewer = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.openModalOnClick = true;
    this.requireOptionKey = false;
  }
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.openModalOnClick = this.settings.openModalOnClick;
      this.requireOptionKey = this.settings.requireOptionKey;
      this.addSettingTab(new SettingsTab(this.app, this));
      this.registerDomEvent(document, "click", (evt) => {
        if (!this.openModalOnClick)
          return;
        if (this.requireOptionKey && !evt.altKey)
          return;
        this.handleClick(evt.target);
      });
      if (this.settings.displayRibbonIcon) {
        this.showRibbonIcon();
      }
    });
  }
  onunload() {
  }
  showRibbonIcon() {
    this.ribbonIcon = this.addRibbonIcon("hashtag", "Tagged Documents Viewer", (evt) => {
      new TaggedDocumentsModal(this.app, "").open();
    });
  }
  hideRibbonIcon() {
    this.ribbonIcon.remove();
  }
  onSettingChange(setting, value) {
    switch (setting) {
      case 0 /* DisplayRibbonIcon */:
        if (value)
          this.showRibbonIcon();
        else
          this.hideRibbonIcon();
        return;
      case 1 /* OpenModalOnClick */:
        this.openModalOnClick = value;
        return;
      case 2 /* RequireOptionKey */:
        this.requireOptionKey = value;
        return;
    }
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
    });
  }
  isTagNode(target) {
    return target.classList.contains("tag") || target.classList.contains("cm-hashtag");
  }
  handleClick(target) {
    return __async(this, null, function* () {
      if (!this.isTagNode(target))
        return;
      const tag = target.innerText;
      new TaggedDocumentsModal(this.app, tag).open();
    });
  }
};
var TaggedDocumentsModal = class extends import_obsidian.Modal {
  constructor(app, tag) {
    super(app);
    this.contents = [];
    this.tag = "";
    this.querying = false;
    this.tag = tag;
    this.contents = [];
  }
  getTaglists() {
    const tags = this.tag.split(" ");
    const include = tags.filter((tag) => tag.charAt(0) !== "!");
    const exclude = tags.filter((tag) => tag.charAt(0) === "!").map((tag) => tag.substring(1));
    return [include, exclude];
  }
  hasTag(tags, value) {
    if (!tags.length || !Array.isArray(tags))
      return false;
    return tags.some((v) => v.toLocaleLowerCase() === value.toLocaleLowerCase());
  }
  getAllFilesMatchingTag(app, tag) {
    const files = app.vault.getMarkdownFiles();
    const result = /* @__PURE__ */ new Set();
    for (let file of files) {
      const tags = (0, import_obsidian.getAllTags)(app.metadataCache.getCache(file.path)) || [];
      if (this.hasTag(tags, `#${tag}`)) {
        result.add(file);
      }
    }
    return result;
  }
  getFilesFromTag(tags) {
    return tags.reduce((accumulator, tag) => {
      return [...accumulator, ...Array.from(this.getAllFilesMatchingTag(this.app, tag) || [])];
    }, []);
  }
  getFiles() {
    const [tagsToInclude, tagsToExclude] = this.getTaglists();
    const startingFiles = this.getFilesFromTag(tagsToInclude);
    const filesToExclude = this.getFilesFromTag(tagsToExclude).map((file) => file.path);
    return startingFiles.filter((file) => !filesToExclude.includes(file.path));
  }
  getPages() {
    return __async(this, null, function* () {
      const files = this.getFiles();
      const numFiles = files.length;
      const contents = [];
      for (let i = 0; i < numFiles; i++) {
        const file = files[i];
        contents.push({ file, text: yield this.app.vault.cachedRead(file) });
      }
      return contents;
    });
  }
  getListContents() {
    return __async(this, null, function* () {
      const contents = yield this.getPages();
      const ul = document.createElement("ul");
      contents.forEach((_0) => __async(this, [_0], function* ({ file, text }) {
        const li = ul.createEl("li");
        const title = document.createElement("h3");
        const link = createLink(this.app, file, () => this.close());
        const content = document.createElement("div");
        yield import_obsidian.MarkdownRenderer.renderMarkdown(text, content, file.path);
        li.appendChild(title);
        title.appendChild(link);
        li.appendChild(content);
      }));
      return ul;
    });
  }
  makeListItems() {
    return __async(this, null, function* () {
      const list = document.querySelector("[data-tageed-documents-viewer-list]");
      list.innerHTML = "";
      this.querying = true;
      list.appendChild(yield this.getListContents());
      this.querying = false;
    });
  }
  tagQuerySubmitLister() {
    return __async(this, null, function* () {
      if (this.querying)
        return;
      const inputEl = document.querySelector("[data-tag-names]");
      this.tag = inputEl.value;
      yield this.makeListItems();
    });
  }
  tagQueryKeyListener(event) {
    if (event.key === "Enter") {
      this.tagQuerySubmitLister();
    }
  }
  renderContainer() {
    const container = document.createElement("div");
    container.addClass("tagged-documents-viewer-container");
    return container;
  }
  renderInput() {
    const input = document.createElement("input");
    this.input = input;
    input.value = this.tag;
    input.setAttribute("data-tag-names", "");
    input.addEventListener("keypress", this.tagQueryKeyListener.bind(this));
    return input;
  }
  renderButton() {
    const button = document.createElement("button");
    this.button = button;
    button.innerText = "OK";
    button.addEventListener("click", this.tagQuerySubmitLister.bind(this));
    return button;
  }
  renderForm() {
    const form = document.createElement("div");
    form.addClass("tagged-documents-viewer-form");
    const input = this.renderInput();
    input.setAttribute("placeholder", "tag-1 tag-2 !not-tag-3");
    const button = this.renderButton();
    form.appendChild(input);
    form.appendChild(button);
    return form;
  }
  renderList() {
    return __async(this, null, function* () {
      const list = document.createElement("div");
      list.setAttribute("data-tageed-documents-viewer-list", "");
      list.addClass("tagged-documents-viewer-list-container");
      const listContents = yield this.getListContents();
      list.appendChild(listContents);
      return list;
    });
  }
  renderLayout() {
    return __async(this, null, function* () {
      const { contentEl } = this;
      contentEl.empty();
      const container = this.renderContainer();
      const form = this.renderForm();
      const list = yield this.renderList();
      container.appendChild(form);
      container.appendChild(list);
      contentEl.appendChild(container);
      return list;
    });
  }
  onOpen() {
    return __async(this, null, function* () {
      const list = yield this.renderLayout();
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.button.removeEventListener("click", this.tagQuerySubmitLister);
    this.input.removeEventListener("keydown", this.tagQueryKeyListener);
  }
};


/* nosourcemap */